{"id":1049185804,"lang":"java","lang_name":"Java","time":"2 months, 3 weeks","timestamp":1694687155,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1049185804/","is_pending":"Not Pending","title":"Reverse Pairs","memory":"N/A","code":"class Solution {\n    int count = 0;\n    public int reversePairs(int[] nums) {\n        // simply apply the merge sort algorithm\n        sort(nums, 0, nums.length-1);\n        // System.out.println(Arrays.toString(arr));\n        return count;\n    }\n\n    void merge(int arr[], int l, int m, int r)\n    {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n \n        // Create temp arrays\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n \n        // Copy data to temp arrays\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n \n        // Merge the temp arrays\n \n        // Initial indices of first and second subarrays\n        int i = 0, j = 0;\n \n        // Initial index of merged subarray array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            }\n            else {\n                // count the inversions here\n                if(R[j] * 2 < L[i])\n                    count += n1 - i;\n                else {\n                    int tempIdx = i;\n                    while(tempIdx < n1 && R[j] * 2 >= L[tempIdx]) tempIdx++;\n                    count += n1 - tempIdx;\n                }\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        // Copy remaining elements of L[] if any\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n \n        // Copy remaining elements of R[] if any\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n \n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(int arr[], int l, int r)\n    {\n        if (l < r) {\n \n            // Find the middle point\n            int m = l + (r - l) / 2;\n \n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n \n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n}","compare_result":"11111111010011111111111111111111100011111111111111111011111111111111111111000110100111100101001001101001000010001100100000000000110000000010","title_slug":"reverse-pairs","has_notes":false,"flag_type":1}