{"id":940996363,"lang":"java","lang_name":"Java","time":"7 months, 1 week","timestamp":1682668640,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/940996363/","is_pending":"Not Pending","title":"Intersection of Two Linked Lists","memory":"45.4 MB","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // ArrayList<String> x = new ArrayList<>();\n        // while(headA != null) {\n        //     x.add(String.valueOf(headA));\n        //     headA = headA.next;\n        // }\n\n        // while(headB != null) {\n        //     if(x.contains(String.valueOf(headB)))\n        //         break;\n        //     headB = headB.next;\n        // }\n\n        // return headB;\n\n        // getting middle of both\n        // ListNode midA = findMid(headA);\n        // ListNode midB = findMid(headB);\n\n        // if(midA == midB) {\n        //     return midA;\n        // } else if(midA.next == midB) {\n        //     return midB;\n        // } else if(midB.next == midA) {\n        //     return midA;\n        // }\n\n        // return null;\n\n        // using concatenation approach\n\n        // ListNode a = headA;\n        // ListNode b = headB;\n\n        // while(a.next != null) {\n        //     a = a.next;\n        // }\n\n        // while(b.next != null) {\n        //     b = b.next;\n        // }\n\n        // a.next = headB;\n        // b.next = headA;\n\n        // a = headA;\n        // b = headB;\n\n        // while(a != null && b != null) {\n        //     if(a.next == b.next) {\n        //         return a.next;\n        //     }\n\n        //     a = a.next;\n        //     b = b.next;\n        // } \n\n        // return null;\n            \nif(headA == null || headB == null) return null;\n    \n    ListNode a = headA;\n    ListNode b = headB;\n    \n    //if a & b have different len, then we will stop the loop after second iteration\n    while( a != b){\n    \t//for the end of first iteration, we just reset the pointer to the head of another linkedlist\n        a = a == null? headB : a.next;\n        b = b == null? headA : b.next;    \n    }\n    \n    return a;\n\n    }\n\n    ListNode findMid(ListNode head) {\n        ListNode slow = head, fast = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return slow;\n    }\n}","compare_result":"111111111111111111111111111111111111111","title_slug":"intersection-of-two-linked-lists","has_notes":false,"flag_type":1}